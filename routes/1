// routes/matches.js
const express = require("express");
const router = express.Router();
const Match = require("../models/match");
const Like = require("../models/Like");
const { requireAuth, authorize } = require("../middlewares/auth");
const { filterMatches } = require("../middleware/leagueFilter");

// ðŸ†• Ø§Ø³ØªØ¯Ø¹Ø§Ø¡ API Ø§Ù„Ù…Ø¯ÙÙˆØ¹
const {
  getLiveMatches,
  getTodayMatches,
  getYesterdayMatches,
  getTomorrowMatches,
  getMatchesByDate,
  getMatchByIdAPI,
  getTeamLastMatches,
  getStandings,
  getLeagues,
  getTeamInfo,
  getTeamPlayers
} = require("../services/footballAPI");

// helper: ÙŠØ­Ø§ÙˆÙ„ ÙŠÙ‚Ø±Ø£ userId Ù„Ùˆ ÙÙŠÙ‡ ØªÙˆÙƒÙ†
function tryGetUserId(req) {
  return req.user?.id || null;
}

/* =========================
   PUBLIC: API FOOTBALL ENDPOINTS
   ========================= */

// ðŸ†• Ù…Ø¨Ø§Ø±ÙŠØ§Øª Ø§Ù„ÙŠÙˆÙ… (Ù…Ù† API Ø®Ø§Ø±Ø¬ÙŠ)
router.get("/today/api", async (req, res) => {
  try {
    const { league } = req.query;
    const matches = await getTodayMatches(league);
    res.json({ source: "API-Football", count: matches.length, matches });
  } catch (err) {
    res.status(500).json({ message: "Error fetching API matches", error: err.message });
  }
});

// ðŸ†• Ù…Ø¨Ø§Ø±Ø§Ø© Ù…Ù† API Ø¨Ø§Ù„Ù€ ID
router.get("/api/:id", async (req, res) => {
  try {
    const match = await getMatchByIdAPI(req.params.id);
    if (!match) return res.status(404).json({ message: "Match not found in API" });
    res.json(match);
  } catch (err) {
    res.status(500).json({ message: "Error fetching API match", error: err.message });
  }
});

// ðŸ†• Ø¬Ø¯ÙˆÙ„ Ø§Ù„ØªØ±ØªÙŠØ¨
router.get("/standings/:leagueId", async (req, res) => {
  try {
    const season = req.query.season || new Date().getFullYear();
    const standings = await getStandings(req.params.leagueId, season);
    res.json({ league: req.params.leagueId, season, standings });
  } catch (err) {
    res.status(500).json({ message: "Error fetching standings", error: err.message });
  }
});

// ðŸ†• Ø¢Ø®Ø± Ù…Ø¨Ø§Ø±ÙŠØ§Øª ÙØ±ÙŠÙ‚
router.get("/team/:teamId/last", async (req, res) => {
  try {
    const count = req.query.count || 5;
    const matches = await getTeamLastMatches(req.params.teamId, count);
    res.json({ teamId: req.params.teamId, matches });
  } catch (err) {
    res.status(500).json({ message: "Error fetching team matches", error: err.message });
  }
});

// ðŸ†• Ù„Ø§Ø¹Ø¨ÙŠ Ø§Ù„ÙØ±ÙŠÙ‚
router.get("/team/:teamId/players", async (req, res) => {
  try {
    const season = req.query.season || new Date().getFullYear();
    const players = await getTeamPlayers(req.params.teamId, season);
    res.json({ teamId: req.params.teamId, season, players });
  } catch (err) {
    res.status(500).json({ message: "Error fetching players", error: err.message });
  }
});

// ðŸ†• Ø§Ù„Ø¯ÙˆØ±ÙŠØ§Øª
router.get("/leagues", async (req, res) => {
  try {
    const { country, season } = req.query;
    const leagues = await getLeagues(country, season);
    res.json({ count: leagues.length, leagues });
  } catch (err) {
    res.status(500).json({ message: "Error fetching leagues", error: err.message });
  }
});

/* =========================
   PUBLIC: DATABASE ENDPOINTS
   ========================= */

// GET /matches (Matches from API-Football with optional date filtering)
router.get("/", async (req, res) => {
  try {
    const { date, timezone, league, live } = req.query;
    
    // If date is provided, fetch from API-Football
    if (date) {
      console.log(`ðŸ“… Fetching matches for date: ${date} (timezone: ${timezone || 'UTC'})`);
      
      // Import services
      const timezoneService = require("../services/timezoneService");
      
      // Get timezone from IP or query params
      const userTimezone = timezone || await timezoneService.getTimezone(req);
      console.log(`ðŸŒ Using timezone: ${userTimezone}`);
      
      // Fetch matches from API-Football for the specified date
      const apiData = await getMatchesByDate(date, userTimezone);
      console.log(`ðŸ“¡ API Matches Response: ${apiData?.length || 0}`);
      
      if (!apiData || apiData.length === 0) {
        console.log("âš ï¸ No matches found for the specified date");
        return res.json([]);
      }

      // Transform API data to match HTML template format with priority sorting
      // Get dynamic priority order from leagues configuration
      const { getAllowedLeagues } = require('../config/leagues');
      const allowedLeagues = getAllowedLeagues();
      const priorityOrder = allowedLeagues
        .sort((a, b) => a.priority - b.priority)
        .map(league => league.id);
      
      let formattedMatches = apiData.map(match => ({
        _id: match.fixture.id.toString(),
        apiId: match.fixture.id,
        homeTeam: {
          name: match.teams.home.name,
          logo: match.teams.home.logo,
          id: match.teams.home.id
        },
        awayTeam: {
          name: match.teams.away.name,
          logo: match.teams.away.logo,
          id: match.teams.away.id
        },
        scoreA: match.goals.home ?? 0,
        scoreB: match.goals.away ?? 0,
        date: match.fixture.date,
        status: match.fixture.status.short,
        minute: match.fixture.status.elapsed || 0,
        venue: match.fixture.venue?.name || "Unknown Venue",
        tournament: {
          name: match.league.name,
          country: match.league.country,
          id: match.league.id,
          logo: match.league.logo
        },
        timezone: userTimezone,
        updatedAt: new Date(),
        // Add priority for sorting
        priority: priorityOrder.indexOf(match.league.id)
      }));

      // Apply league filtering (same as HTML template)
      if (league && league !== 'all') {
        const leagueId = parseInt(league);
        formattedMatches = formattedMatches.filter(match => match.tournament.id === leagueId);
        console.log(`ðŸ” Filtered by league ${leagueId}: ${formattedMatches.length} matches`);
      }

      if (live === 'true') {
        const liveStatuses = ['1H', 'HT', '2H', 'ET', 'P'];
        formattedMatches = formattedMatches.filter(match => liveStatuses.includes(match.status));
        console.log(`ðŸ”´ Filtered live matches: ${formattedMatches.length} matches`);
      }

      // Apply league filtering to only show allowed leagues
      formattedMatches = filterMatches(formattedMatches);
      console.log(`ðŸ” League Filter: ${formattedMatches.length} matches after filtering`);

      // Sort matches by priority (same as HTML template)
      formattedMatches.sort((a, b) => {
        const aPrio = a.priority;
        const bPrio = b.priority;
        
        if (aPrio !== -1 && bPrio !== -1) return aPrio - bPrio; // Both are important
        if (aPrio !== -1) return -1; // a is important, b is not
        if (bPrio !== -1) return 1; // b is important, a is not
        
        return a.tournament.name.localeCompare(b.tournament.name); // Neither is important, sort alphabetically
      });

      console.log(`âœ… Returning ${formattedMatches.length} matches for ${date}`);
      return res.json(formattedMatches);
    }
    
    // If no date provided, fetch from database (legacy behavior)
    const matches = await Match.find()
      .populate("homeTeam", "name country logo")
      .populate("awayTeam", "name country logo")
      .populate("tournament", "name year country")
      .sort({ date: -1 });

    const userId = tryGetUserId(req);

    const matchesWithLikes = await Promise.all(
      matches.map(async (match) => {
        const likesCount = await Like.countDocuments({ targetType: "Match", targetId: match._id });
        let userLiked = false;
        if (userId) {
          userLiked = !!(await Like.exists({ user: userId, targetType: "Match", targetId: match._id }));
        }
        return { ...match.toObject(), likes: likesCount, likedByUser: userLiked };
      })
    );

    res.json(matchesWithLikes);
  } catch (err) {
    console.error("âŒ Error fetching matches:", err);
    res.status(500).json({ message: "Error fetching matches", error: err.message });
  }
});

// GET /matches/today (Today's matches with timezone support)
router.get("/today", async (req, res) => {
  try {
    console.log("ðŸ“… Fetching today's matches from API-Football...");
    
    // Import services
    const footballAPI = require("../services/footballAPI");
    const timezoneService = require("../services/timezoneService");
    
    // Get timezone from IP or query params
    const timezone = await timezoneService.getTimezone(req);
    console.log(`ðŸŒ Using timezone: ${timezone}`);
    
    // Fetch today's matches from API-Football with timezone
    const apiData = await getTodayMatches(timezone);
    console.log(`ðŸ“¡ API Today's Matches Response: ${apiData?.length || 0}`);
    
    if (!apiData || apiData.length === 0) {
      console.log("âš ï¸ No matches found for today");
      return res.json([]);
    }

    // Transform API data to match our frontend format with timezone filtering
    const todayMatches = apiData
      .filter(match => {
        // Additional filtering to ensure match is actually today in user's timezone
        const matchDate = new Date(match.fixture.date);
        const today = new Date();
        
        // Check if match date is today in user's timezone
        const matchDateStr = matchDate.toLocaleDateString('en-CA', { timeZone: timezone });
        const todayStr = today.toLocaleDateString('en-CA', { timeZone: timezone });
        
        return matchDateStr === todayStr;
      })
      .map(match => ({
        _id: match.fixture.id.toString(),
        apiId: match.fixture.id,
        homeTeam: {
          name: match.teams.home.name,
          logo: match.teams.home.logo,
          id: match.teams.home.id
        },
        awayTeam: {
          name: match.teams.away.name,
          logo: match.teams.away.logo,
          id: match.teams.away.id
        },
        scoreA: match.goals.home ?? 0,
        scoreB: match.goals.away ?? 0,
        date: match.fixture.date,
        status: match.fixture.status.short.toLowerCase(),
        minute: match.fixture.status.elapsed || 0,
        venue: match.fixture.venue?.name || "Unknown Venue",
        tournament: {
          name: match.league.name,
          country: match.league.country,
          id: match.league.id
        },
        timezone: timezone,
        updatedAt: new Date()
      }));

    // Apply league filtering to only show allowed leagues
    const filteredTodayMatches = filterMatches(todayMatches);
    console.log(`ðŸ” League Filter: ${todayMatches.length} â†’ ${filteredTodayMatches.length} today's matches after filtering`);

    console.log(`âœ… Returning ${filteredTodayMatches.length} today's matches`);
    res.json(filteredTodayMatches);
  } catch (err) {
    console.error("âŒ Error fetching today's matches:", err);
    res.status(500).json({ error: "Error fetching today's matches", details: err.message });
  }
});

// GET /matches/yesterday (Yesterday's matches with timezone support)
router.get("/yesterday", async (req, res) => {
  try {
    console.log("ðŸ“… Fetching yesterday's matches from API-Football...");
    
    // Import services
    const footballAPI = require("../services/footballAPI");
    const timezoneService = require("../services/timezoneService");
    
    // Get timezone from IP or query params
    const timezone = await timezoneService.getTimezone(req);
    console.log(`ðŸŒ Using timezone: ${timezone}`);
    
    // Fetch yesterday's matches from API-Football with timezone
    const apiData = await getYesterdayMatches(timezone);
    console.log(`ðŸ“¡ API Yesterday's Matches Response: ${apiData?.length || 0}`);
    
    if (!apiData || apiData.length === 0) {
      console.log("âš ï¸ No matches found for yesterday");
      return res.json([]);
    }

    // Transform API data to match our frontend format with timezone filtering
    const yesterdayMatches = apiData
      .filter(match => {
        // Additional filtering to ensure match is actually yesterday in user's timezone
        const matchDate = new Date(match.fixture.date);
        const yesterday = new Date();
        yesterday.setDate(yesterday.getDate() - 1);
        
        // Check if match date is yesterday in user's timezone
        const matchDateStr = matchDate.toLocaleDateString('en-CA', { timeZone: timezone });
        const yesterdayStr = yesterday.toLocaleDateString('en-CA', { timeZone: timezone });
        
        return matchDateStr === yesterdayStr;
      })
      .map(match => ({
      _id: match.fixture.id.toString(),
      apiId: match.fixture.id,
      homeTeam: {
        name: match.teams.home.name,
        logo: match.teams.home.logo,
        id: match.teams.home.id
      },
      awayTeam: {
        name: match.teams.away.name,
        logo: match.teams.away.logo,
        id: match.teams.away.id
      },
      scoreA: match.goals.home ?? 0,
      scoreB: match.goals.away ?? 0,
      date: match.fixture.date,
      status: match.fixture.status.short.toLowerCase(),
      minute: match.fixture.status.elapsed || 0,
      venue: match.fixture.venue?.name || "Unknown Venue",
      tournament: {
        name: match.league.name,
        country: match.league.country,
        id: match.league.id
      },
      timezone: timezone,
      updatedAt: new Date()
    }));

    // Apply league filtering to only show allowed leagues
    const filteredYesterdayMatches = filterMatches(yesterdayMatches);
    console.log(`ðŸ” League Filter: ${yesterdayMatches.length} â†’ ${filteredYesterdayMatches.length} yesterday's matches after filtering`);

    console.log(`âœ… Returning ${filteredYesterdayMatches.length} yesterday's matches`);
    res.json(filteredYesterdayMatches);
  } catch (err) {
    console.error("âŒ Error fetching yesterday's matches:", err);
    res.status(500).json({ error: "Error fetching yesterday's matches", details: err.message });
  }
});

// GET /matches/tomorrow (Tomorrow's matches with timezone support)
router.get("/tomorrow", async (req, res) => {
  try {
    console.log("ðŸ“… Fetching tomorrow's matches from API-Football...");
    
    // Import services
    const footballAPI = require("../services/footballAPI");
    const timezoneService = require("../services/timezoneService");
    
    // Get timezone from IP or query params
    const timezone = await timezoneService.getTimezone(req);
    console.log(`ðŸŒ Using timezone: ${timezone}`);
    
    // Fetch tomorrow's matches from API-Football with timezone
    const apiData = await getTomorrowMatches(timezone);
    console.log(`ðŸ“¡ API Tomorrow's Matches Response: ${apiData?.length || 0}`);
    
    if (!apiData || apiData.length === 0) {
      console.log("âš ï¸ No matches found for tomorrow");
      return res.json([]);
    }

    // Transform API data to match our frontend format with timezone filtering
    const tomorrowMatches = apiData
      .filter(match => {
        // Additional filtering to ensure match is actually tomorrow in user's timezone
        const matchDate = new Date(match.fixture.date);
        const tomorrow = new Date();
        tomorrow.setDate(tomorrow.getDate() + 1);
        
        // Check if match date is tomorrow in user's timezone
        const matchDateStr = matchDate.toLocaleDateString('en-CA', { timeZone: timezone });
        const tomorrowStr = tomorrow.toLocaleDateString('en-CA', { timeZone: timezone });
        
        return matchDateStr === tomorrowStr;
      })
      .map(match => ({
      _id: match.fixture.id.toString(),
      apiId: match.fixture.id,
      homeTeam: {
        name: match.teams.home.name,
        logo: match.teams.home.logo,
        id: match.teams.home.id
      },
      awayTeam: {
        name: match.teams.away.name,
        logo: match.teams.away.logo,
        id: match.teams.away.id
      },
      scoreA: match.goals.home ?? 0,
      scoreB: match.goals.away ?? 0,
      date: match.fixture.date,
      status: match.fixture.status.short.toLowerCase(),
      minute: match.fixture.status.elapsed || 0,
      venue: match.fixture.venue?.name || "Unknown Venue",
      tournament: {
        name: match.league.name,
        country: match.league.country,
        id: match.league.id
      },
      timezone: timezone,
      updatedAt: new Date()
    }));

    // Apply league filtering to only show allowed leagues
    const filteredTomorrowMatches = filterMatches(tomorrowMatches);
    console.log(`ðŸ” League Filter: ${tomorrowMatches.length} â†’ ${filteredTomorrowMatches.length} tomorrow's matches after filtering`);

    console.log(`âœ… Returning ${filteredTomorrowMatches.length} tomorrow's matches`);
    res.json(filteredTomorrowMatches);
  } catch (err) {
    console.error("âŒ Error fetching tomorrow's matches:", err);
    res.status(500).json({ error: "Error fetching tomorrow's matches", details: err.message });
  }
});

// GET /matches/live (Real-time from API-Football)
router.get("/live", async (req, res) => {
  try {
    console.log("ðŸ”´ Fetching live matches from API-Football...");
    
    // Always fetch fresh live data from API-Football for real-time updates
    const apiData = await getLiveMatches();
    console.log(`ðŸ“¡ API Live Matches Response: ${apiData?.length || 0}`);
    
    if (!apiData || apiData.length === 0) {
      console.log("âš ï¸ No live matches found from API");
      return res.json([]);
    }

    // Transform API data to match our frontend format with live indicators
    const liveMatches = apiData.map(match => {
      const status = match.fixture.status.short;
      const elapsed = match.fixture.status.elapsed;
      
      // Determine live status and display text
      let liveStatus = "LIVE";
      let liveDisplay = "";
      let isLive = false;
      
      if (status === "LIVE" || status === "1H" || status === "2H" || status === "HT") {
        isLive = true;
        if (status === "HT") {
          liveDisplay = "HT";
        } else if (status === "1H") {
          liveDisplay = elapsed ? `${elapsed}'` : "1H";
        } else if (status === "2H") {
          liveDisplay = elapsed ? `${elapsed}'` : "2H";
        } else {
          liveDisplay = elapsed ? `${elapsed}'` : "LIVE";
        }
      }
      
      return {
        _id: match.fixture.id.toString(),
        apiId: match.fixture.id,
        homeTeam: {
          name: match.teams.home.name,
          logo: match.teams.home.logo,
          id: match.teams.home.id
        },
        awayTeam: {
          name: match.teams.away.name,
          logo: match.teams.away.logo,
          id: match.teams.away.id
        },
        scoreA: match.goals.home ?? 0,
        scoreB: match.goals.away ?? 0,
        date: match.fixture.date,
        status: status.toLowerCase(),
        minute: elapsed || 0,
        liveStatus: liveStatus,
        liveDisplay: liveDisplay,
        isLive: isLive,
        venue: match.fixture.venue?.name || "Unknown Venue",
        tournament: {
          name: match.league.name,
          country: match.league.country,
          id: match.league.id
        },
        updatedAt: new Date()
      };
    });

    // Apply league filtering to only show allowed leagues
    const filteredLiveMatches = filterMatches(liveMatches);
    console.log(`ðŸ” League Filter: ${liveMatches.length} â†’ ${filteredLiveMatches.length} live matches after filtering`);

    console.log(`âœ… Returning ${filteredLiveMatches.length} live matches directly from API`);
    res.json(filteredLiveMatches);
  } catch (err) {
    console.error("âŒ Error fetching live matches:", err);
    res.status(500).json({ error: "Error fetching live matches", details: err.message });
  }
});

// GET /matches/timezone (Get user's timezone information)
router.get("/timezone", async (req, res) => {
  try {
    console.log("ðŸŒ Getting user timezone information...");
    
    // Import timezone service
    const timezoneService = require("../services/timezoneService");
    
    // Get user's IP (same logic as getTimezone method)
    let userIP = timezoneService.getUserIP(req);
    console.log(`ðŸ“ Initial userIP: ${userIP}`);
    
    // If we got null (local network), fetch public IP
    if (!userIP) {
      console.log(`ðŸŒ Fetching public IP from external service...`);
      try {
        const axios = require('axios');
        const publicIPResponse = await axios.get('https://api.ipify.org?format=json', { timeout: 5000 });
        userIP = publicIPResponse.data.ip;
        console.log(`ðŸŒ Public IP detected: ${userIP}`);
      } catch (error) {
        console.log(`âš ï¸ Could not fetch public IP: ${error.message}, using local IP detection`);
        userIP = req.ip || '127.0.0.1';
      }
    }
    
    console.log(`ðŸ“ Final userIP: ${userIP}`);
    
    // Get timezone
    const timezone = await timezoneService.getTimezone(req);
    
    // Get common timezones for reference
    const commonTimezones = timezoneService.getCommonTimezones();
    
    res.json({
      timezone,
      userIP,
      commonTimezones,
      detected: timezone !== 'UTC' || req.query.timezone
    });
  } catch (err) {
    console.error("âŒ Error getting timezone:", err);
    res.status(500).json({ 
      error: "Error getting timezone", 
      details: err.message,
      timezone: 'UTC',
      userIP: req.ip || 'unknown'
    });
  }
});

// GET /matches/template - New endpoint that matches HTML template data structure
router.get("/template", async (req, res) => {
  try {
    const { date } = req.query;
    
    if (!date) {
      return res.status(400).json({ message: "Date parameter is required" });
    }
    
    console.log(`ðŸ“… Fetching matches for template format: ${date}`);
    
    // Use the updated getMatchesByDate method
    const apiData = await getMatchesByDate(date);
    
    if (!apiData || apiData.length === 0) {
      console.log("âš ï¸ No matches found for the specified date");
      return res.json([]);
    }

    // Return data in the same format as HTML template
    const templateData = apiData.map(match => ({
      fixture: {
        id: match.fixture.id,
        date: match.fixture.date,
        status: {
          short: match.fixture.status.short,
          long: match.fixture.status.long,
          elapsed: match.fixture.status.elapsed
        }
      },
      teams: {
        home: {
          id: match.teams.home.id,
          name: match.teams.home.name,
          logo: match.teams.home.logo
        },
        away: {
          id: match.teams.away.id,
          name: match.teams.away.name,
          logo: match.teams.away.logo
        }
      },
      goals: {
        home: match.goals.home,
        away: match.goals.away
      },
      league: {
        id: match.league.id,
        name: match.league.name,
        country: match.league.country,
        logo: match.league.logo
      }
    }));

    // Debug: Log league IDs for sorting verification
    const leagueIds = [...new Set(templateData.map(match => match.league.id))];
    console.log('League IDs in response:', leagueIds);
    
    console.log(`âœ… Returning ${templateData.length} matches in template format`);
    res.json(templateData);
  } catch (err) {
    console.error("âŒ Error fetching template matches:", err);
    res.status(500).json({ message: "Error fetching template matches", error: err.message });
  }
});

// GET /matches/:id (Ù…Ø¨Ø§Ø±Ø§Ø© Ù…Ù† Ø§Ù„Ø¯Ø§ØªØ§Ø¨ÙŠØ²)
router.get("/:id", async (req, res) => {
  try {
    const match = await Match.findById(req.params.id)
      .populate("homeTeam", "name country logo")
      .populate("awayTeam", "name country logo")
      .populate("tournament", "name year country");

    if (!match) return res.status(404).json({ message: "Match not found" });

    res.json(match);
  } catch (err) {
    res.status(500).json({ message: "Error fetching match", error: err.message });
  }
});

/* =========================
   PROTECTED: ADMIN OPS
   ========================= */

// âž• Ø¥Ø¶Ø§ÙØ© Ù…Ø¨Ø§Ø±Ø§Ø©
router.post("/", requireAuth, authorize("match:create"), async (req, res) => {
  try {
    const match = new Match(req.body);
    await match.save();
    res.status(201).json({ message: "Match created", match });
  } catch (err) {
    res.status(400).json({ message: "Error creating match", error: err.message });
  }
});

// âœï¸ ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù†ØªÙŠØ¬Ø©
router.put("/:id/score", requireAuth, authorize("match:edit"), async (req, res) => {
  try {
    const { scoreA, scoreB, minute } = req.body;
    const match = await Match.findByIdAndUpdate(
      req.params.id,
      { scoreA, scoreB, minute, status: "live" },
      { new: true }
    );
    if (!match) return res.status(404).json({ message: "Match not found" });

    if (global.sendLiveScoreUpdate) {
      global.sendLiveScoreUpdate(match._id, {
        homeScore: match.scoreA,
        awayScore: match.scoreB,
        minute: match.minute,
      });
    }

    res.json({ message: "Score updated", match });
  } catch (err) {
    res.status(500).json({ message: "Error updating score", error: err.message });
  }
});

// ðŸ—‘ï¸ Ø­Ø°Ù Ù…Ø¨Ø§Ø±Ø§Ø©
router.delete("/:id", requireAuth, authorize("match:delete"), async (req, res) => {
  try {
    const deleted = await Match.findByIdAndDelete(req.params.id);
    if (!deleted) return res.status(404).json({ message: "Match not found" });
    res.json({ message: "Match deleted" });
  } catch (err) {
    res.status(500).json({ message: "Error deleting match", error: err.message });
  }
});

module.exports = router;